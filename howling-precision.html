<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>高精度ハウリング解析（31バンドEQ・k表示）</title>
<style>
body{ background:#111; color:white; font-family:sans-serif; text-align:center; padding:20px; }
button{ padding:12px 18px; margin:10px; font-size:16px; border:none; border-radius:6px; background:#007AFF; color:white; cursor:pointer;}
button:disabled{ background:#444; }
canvas{ width:100%; height:260px; background:#000; margin-top:20px; border:1px solid #333;}
table{ width:100%; margin-top:20px; border-collapse:collapse; background:#222;}
th,td{ border:1px solid #444; padding:10px; text-align:center;}
th{ background:#333; color:#00ff99;}
.eq-match{ color:#ffcc00; font-weight:bold; font-size:1.1em;} 
</style>
</head>
<body>

<h2>高精度ハウリング解析（31バンドEQ対応）</h2>

<button id="recordBtn">5秒録音して解析</button>
<button onclick="location.href='index.html'" style="background:#555;">← 戻る</button>

<canvas id="canvas" width="800" height="260"></canvas>

<h3>持続ピーク候補（上位10件）</h3>
<table>
<thead>
<tr>
  <th>順位</th>
  <th>検出周波数</th>
  <th>強度(dB)</th>
  <th>対応する31点EQ</th>
</tr>
</thead>
<tbody id="result"></tbody>
</table>

<script>
let recordBtn = document.getElementById("recordBtn");
let canvas = document.getElementById("canvas");
let ctx = canvas.getContext("2d");

const MIN_FREQ = 20;
const MAX_FREQ = 20000;

// 標準的な31バンドEQの周波数リスト（Hz単位）
const EQ_BANDS_31 = [
  20, 25, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630, 800, 
  1000, 1250, 1600, 2000, 2500, 3150, 4000, 5000, 6300, 8000, 10000, 12500, 16000, 20000
];

// 周波数を「k」表示に変換する関数
function formatFreq(freq) {
  if (freq >= 1000) {
    let kValue = freq / 1000;
    // 小数点第2位までで、きりが良ければ小数点以下を消す
    return parseFloat(kValue.toFixed(2)) + "k";
  }
  return freq + "";
}

function getNearestEQ(freq) {
  return EQ_BANDS_31.reduce((prev, curr) => {
    return (Math.abs(curr - freq) < Math.abs(prev - freq) ? curr : prev);
  });
}

recordBtn.onclick = async () => {
  try {
    recordBtn.disabled = true;
    recordBtn.textContent = "録音中...";
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    const mediaRecorder = new MediaRecorder(stream);
    let chunks = [];
    mediaRecorder.ondataavailable = e => chunks.push(e.data);
    mediaRecorder.start();
    setTimeout(()=>mediaRecorder.stop(), 5000);

    mediaRecorder.onstop = async () => {
      const blob = new Blob(chunks);
      const arrayBuffer = await blob.arrayBuffer();
      const audioCtx = new AudioContext();
      const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
      analyzeBuffer(audioBuffer);
      recordBtn.disabled = false;
      recordBtn.textContent = "5秒録音して解析";
    };
  } catch (err) {
    alert("マイクの使用が許可されませんでした。");
    recordBtn.disabled = false;
    recordBtn.textContent = "5秒録音して解析";
  }
};

async function analyzeBuffer(audioBuffer){
  const offlineCtx = new OfflineAudioContext(1, audioBuffer.length, audioBuffer.sampleRate);
  const source = offlineCtx.createBufferSource();
  source.buffer = audioBuffer;
  const analyser = offlineCtx.createAnalyser();
  analyser.fftSize = 16384; 
  analyser.smoothingTimeConstant = 0;
  source.connect(analyser);
  analyser.connect(offlineCtx.destination);
  source.start(0);
  await offlineCtx.startRendering();
  const dataArray = new Float32Array(analyser.frequencyBinCount);
  analyser.getFloatFrequencyData(dataArray);
  drawSpectrum(dataArray, audioBuffer.sampleRate, analyser.fftSize);
  detectPeaks(dataArray, audioBuffer.sampleRate, analyser.fftSize);
}

function logPosition(freq){
  let minLog = Math.log10(MIN_FREQ);
  let maxLog = Math.log10(MAX_FREQ);
  let freqLog = Math.log10(freq);
  return (freqLog - minLog) / (maxLog - minLog);
}

function drawSpectrum(data, sampleRate, fftSize){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  let max = -30, min = -120;
  for(let i=0;i<data.length;i++){
    let freq = i * sampleRate / fftSize;
    if(freq < MIN_FREQ || freq > MAX_FREQ) continue;
    let x = logPosition(freq) * canvas.width;
    let norm = (data[i] - min) / (max - min);
    let height = norm * canvas.height;
    ctx.fillStyle="#00ff99";
    ctx.fillRect(x, canvas.height-height, 1, height);
  }
}

function detectPeaks(data, sampleRate, fftSize){
  let peaks = [];
  for(let i=5; i<data.length-5; i++){
    let freq = i * sampleRate / fftSize;
    if(freq < MIN_FREQ || freq > MAX_FREQ) continue;
    let val = data[i];
    let localAvg = 0;
    for(let j=-5; j<=5; j++){ if(j!==0) localAvg += data[i+j]; }
    localAvg /= 10;
    if(val > localAvg + 6){
      peaks.push({freq: Math.round(freq), score: val});
    }
  }

  peaks.sort((a,b)=>b.score-a.score);
  peaks = peaks.slice(0, 10);

  const tbody = document.getElementById("result");
  tbody.innerHTML="";
  peaks.forEach((p, index)=>{
    const nearestEQ = getNearestEQ(p.freq);
    tbody.innerHTML += `
      <tr>
        <td>${index+1}</td>
        <td>${formatFreq(p.freq)}Hz</td>
        <td>${p.score.toFixed(1)} dB</td>
        <td class="eq-match">${formatFreq(nearestEQ)}Hz</td>
      </tr>
    `;
  });
}
</script>
</body>
</html>
